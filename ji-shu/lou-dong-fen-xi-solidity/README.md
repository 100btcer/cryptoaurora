# 漏洞分析

## 智能合约安全检查清单 <a href="#zhi-neng-he-yue-an-quan-jian-cha-qing-dan" id="zhi-neng-he-yue-an-quan-jian-cha-qing-dan"></a>

1. **Solidity版本**。使用非常老的Solidity版本，无法从错误修复和较新的安全检查中获益。使用最新版本可能会使合约容易受到未发现的编译器错误的影响。请考虑使用这些版本之一：_0.5.11-0.5.13、0.5.15-0.5.17、0.6.8或0.6.10-0.6.11._（见[此处](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-versions-of-solidity)）。
2. **未锁定版本**。合约应使用与其测试过的编译器版本/标志去部署。锁定 pragma(例如在`pragma solidity 0.5.10`中不使用 _^_ ) 可以确保合约不会意外地被部署到一个有未修正错误的旧编译器版本。(见[这里](https://swcregistry.io/docs/SWC-103))
3. **同时使用多个Solidity pragma**。最好在所有合约中使用一个Solidity编译器版本，而不是使用有不同错误和安全检查的不同版本。(见[这里](https://github.com/crytic/slither/wiki/Detector-Documentation#different-pragma-directives-are-used))
4. **不正确的访问控制**。执行关键逻辑的合约函数应通过地址检查(如所有者、控制器等)进行适当的访问控制，通常是在[修改器](https://learnblockchain.cn/docs/solidity/contracts.html#modifier)中进行的。缺少的检查将允许攻击者控制关键逻辑。(见[这里](https://docs.openzeppelin.com/contracts/3.x/api/access)和[这里](https://dasp.co/#item-2))
5. **不受保护的提款函数**。调用未受保护的(_external_/_public_)函数向用户控制的地址发送以太币/代币，可能允许用户提取未经授权的资金。(见[这里](https://swcregistry.io/docs/SWC-105))
6. **无保护地调用自毁**。用户/攻击者可能会误杀/故意销毁合约。必须控制对此类函数的访问。(见[此处](https://swcregistry.io/docs/SWC-106))
7. \*\*修改器的副作用：\*\*修改器应该只进行状态检查，而不应该更改状态，以及违反[检查-修改-交互（check-effects-interactions）](https://learnblockchain.cn/docs/solidity/security-considerations.html#checks-effects-interactions)模式的外部调用。这些副作用可能会被开发者/审核员忽略，因为修改器的代码通常远离函数实现。(参见[这里](https://consensys.net/blog/blockchain-development/solidity-best-practices-for-smart-contract-security/))
8. **不正确的修改器**。如果一个修改器没有执行_\__或_revert_，使用该修改器的函数将返回默认值，导致意外行为。(参见[这里](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-modifier))
9. \*\*构造函数名称：\*\*在_solc 0.4.22_之前，构造函数名称必须与包含它的合约同名。错误的命名不会使它成为一个构造函数，这对安全有影响。_solc 0.4.22_引入了_constructor_关键字。在_solc 0.5.0_之前，合约可以同时拥有旧式和新式的构造函数名，如果两者都存在，则第一个定义的构造函数名优先于第二个，这也导致了安全问题。_Solc 0.5.0_强制使用_constructor_关键字。(见[这里](https://github.com/crytic/slither/wiki/Detector-Documentation#multiple-constructor-schemes)和[这里](https://swcregistry.io/docs/SWC-118))
10. **无效构造函数**：对基类合约构造函数的调用如果没有实现，会导致假设错误。检查构造函数是否实现，如果没有实现则删除调用。(参见[这里](https://github.com/crytic/slither/wiki/Detector-Documentation#void-constructor))
11. **隐式构造函数callValue检查**。合约没有定义构造函数，但有一个定义了构造函数的基类合约，在没有明确可支付构造函数的情况下，不要revert 返回非零的callValue的调用。这是由于_v0.4.5_中引入的一个编译器错误，在_v0.6.8_中得到了修复。(参见[这里](https://docs.soliditylang.org/en/v0.8.1/bugs.html))
12. **受控的委托调用：** \*delegatecall()_或_callcode()\*到用户控制的地址，将允许在调用者的状态下执行恶意合约。需确保此类调用的目标地址可信。(见[这里](https://swcregistry.io/docs/SWC-112))
13. **重入漏洞**。不受信任的外部合约调用可能会回调自己的合约，导致意想不到的结果，如多次提款或失序事件。使用check-effects-interactions模式或进行重入保护。(见[此处](https://swcregistry.io/docs/SWC-107))
14. \*\*ERC777 回调和重入：\*\*ERC777代币允许通过在代币转让期间调用的钩子进行任意回调。如果不使用重入防护，恶意合约地址可能会导致此类回调的重入攻击。(见[这里](https://quantstamp.com/blog/how-the-dforce-hacker-used-reentrancy-to-steal-25-million))
15. **避免用 transfer() / send() 来作为缓解重入攻击的措施**。虽然\*transfer()_和_send()_被推荐为防止重入攻击的最佳安全做法，因为它们只使用 2300 Gas ，但操作码的 Gas 重新定价可能会破坏已部署的合约。推荐使用_call()\*代替，没有硬编码的 Gas 限制，以及使用”检查-效果-交互“模式或重入防护来保护重入攻击。(见[这里](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/)和[这里](https://swcregistry.io/docs/SWC-134))
16. **私有链上数据**。标明变量为_private_并不意味着不能在链上读取这些变量。私有数据不应该不加密地存储在合约代码或状态中，而应该加密或链外存储。(见[这里](https://swcregistry.io/docs/SWC-136))
17. **弱PRNG**。依靠_block.timestamp_、_now_或_blockhash_的PRNG在一定程度上会受到矿工的影响，应避免使用。(见[这里](https://swcregistry.io/docs/SWC-120))
18. **块值作为时间代理**： _block.timestamp_和_block.number_不是很好的时间代理，因为存在同步、矿工操纵和改变块时间的问题。(见[这里](https://swcregistry.io/docs/SWC-116))
19. **整数上溢/下溢**。若不使用OpenZeppelin的SafeMath(或类似的库)检查溢出/下溢，如果用户/攻击者能够控制这种算术运算的整数操作数，可能会导致漏洞或意外行为。_Solc v0.8.0_为所有算术运算引入了默认的溢出/底溢检查。(见[这里](https://swcregistry.io/docs/SWC-101)和[这里](https://blog.soliditylang.org/2020/10/28/solidity-0.8.x-preview/))
20. \*\*先除后乘：\*\*先乘后除一般比较好，以避免精度损失，因为Solidity整数除法可能会截断。(见[这里](https://github.com/crytic/slither/wiki/Detector-Documentation#divide-before-multiply))
21. \*\*交易顺序依赖：\*\*可以通过监控mempool对特定的以太坊交易强制执行竞赛条件。例如，经典的ERC20 \*approve()\*变更可以使用这种方法进行前置。不要对交易顺序依赖性进行假设。(见[这里](https://swcregistry.io/docs/SWC-114))
22. \*\*ERC20 approve()竞赛条件：\*\*使用OpenZepppelin的_SafeERC20_实现中的\*safeIncreaseAllowance()_和_safeDecreaseAllowance()\*来防止竞赛条件操纵授权金额。(见[这里](https://swcregistry.io/docs/SWC-114))
23. **签名的可塑性**。_ecrecover_函数容易受到签名可塑性的影响，可能导致重放攻击。考虑使用OpenZeppelin的[ECDSA库](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol)。(参见[这里](https://swcregistry.io/docs/SWC-117)、[这里](https://swcregistry.io/docs/SWC-121)和[这里](https://medium.com/cryptronics/signature-replay-vulnerabilities-in-smart-contracts-3b6f7596df57))
24. **ERC20 transfer()不返回boolean:** 用_solc > 0.4.22_编译的合约与这样的函数交互将回退。使用OpenZeppelin的SafeERC20封装器。(参见 [这里](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-erc20-interface) 和 [这里](https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca))
25. **ERC721 ownerOf()不正确的返回值 :** 用_solc > 0.4.22_编译的合约与ERC721 _ownerOf()交互，如果返回一个bool_而不是_address_类型，将会回退。使用OpenZeppelin的ERC721合约。(参见[这里](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-erc721-interface))
26. **意外的以太币和this.balance**。合约可以通过_payable_函数、_selfdestruct()、coinbase_交易或创建前的预发送接收以太币。因此，依赖于_this.balance_的合约逻辑可以被操纵。(参见[这里](https://github.com/sigp/solidity-security-blog#3-unexpected-ether-1)和[这里](https://swcregistry.io/docs/SWC-132))
27. **fallback与receive()**。检查是否考虑了_fallback_/_receive_函数的所有预防措施， 他们与与可见性、状态可变性和以太坊转账有微妙关系。(见 [这里](https://docs.soliditylang.org/en/latest/contracts.html#fallback-function) 和 [这里](https://docs.soliditylang.org/en/latest/contracts.html#receive-ether-function))
28. \*\*危险的==：\*_对代币/Ether使用严格等于可能会意外/恶意地导致意外行为。根据合约逻辑，考虑使用_>=_或_<=_代替_==\*来处理此类变量。(参见[这里](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-strict-equalities))
29. **锁定以太币**。通过_payable_函数接受以太币但没有提款机制的合约将锁定以太币。需去掉_payable_属性或增加提款功能。(见[这里](https://github.com/crytic/slither/wiki/Detector-Documentation#contracts-that-lock-ether))
30. **危险地使用tx.origin**。使用_tx.origin_进行授权可能会被MITM恶意合约滥用。请使用_msg.sender_代替。(见[此处](https://swcregistry.io/docs/SWC-115))
31. \*\*合约检查：\*\*检查是否从外部自有账户（EOA）或合约账户调用，通常使用_extcodesize_检查。但在部署期间，合约还没有源代码时，可能会被合约规避。检查是否_tx.origin == msg.sender_是另一种选择。两者都有需要考虑的影响。(见 [这里](https://consensys.net/blog/blockchain-development/solidity-best-practices-for-smart-contract-security/))
32. **删除在一个结构体的映射**。删除包含映射的结构体不会删除映射的内容，这可能会导致意想不到的后果。(见[此处](https://github.com/crytic/slither/wiki/Detector-Documentation#deletion-on-mapping-containing-a-structure))
33. **恒真或恒假**：恒真(总是真)或恒假(总是假)可能有潜在的逻辑缺陷或多余的检查，例如，_x >= 0_，如果_x_是_uint_，则总是真。(见[这里](https://github.com/crytic/slither/wiki/Detector-Documentation#tautology-or-contradiction))
34. **布尔常数**。在代码中使用布尔常数(_true/false_)(如判断条件)，则表明逻辑有缺陷。(见[这里](https://github.com/crytic/slither/wiki/Detector-Documentation#misuse-of-a-boolean-constant))
35. **布尔相等**。布尔变量可以直接在条件中检查，而不需要使用_true_/_false_的相等运算符。(见[这里](https://github.com/crytic/slither/wiki/Detector-Documentation#boolean-equality))
36. **状态修改函数**。在_solc >=0.5.0_中，修改状态(在汇编中或其他)但被标记为_constant_/_pure_/_view_的函数会因为使用_STATICCALL_操作码而在_solc >=0.5.0_中回退(在之前的版本中工作)。(见[这里](https://github.com/crytic/slither/wiki/Detector-Documentation#constant-functions-using-assembly-code))
37. **低级调用的返回值**。确保检查低级调用(_call_/_callcode_/_delegatecall_/_send_/等)的返回值，以避免意外失败。(见[这里](https://swcregistry.io/docs/SWC-104))
38. **低级调用的账户存在性检查**。即使被调用的账户不存在，低级调用_call_/_delegatecall_/_staticcall_也返回true(根据EVM设计)。如果需要的话，必须在调用前检查账户是否存在。(见[这里](https://github.com/crytic/slither/wiki/Detector-Documentation#low-level-calls))
39. \*\*危险的覆盖：\*\*局部变量、状态变量、函数、修改器或事件的名称会覆盖内置的Solidity符号，如_now_或其他来自当前作用域的声明，这些都会产生误导，并可能导致意外的使用和行为。(参见[这里](https://github.com/crytic/slither/wiki/Detector-Documentation#builtin-symbol-shadowing))
40. **危险的状态变量覆盖**。在派生合约中覆盖状态变量可能会对关键变量造成危险，如合约所有人owner(例如，基础合约中的修改器检查该变量，但变量被错误地覆盖了)，以及合约错误地使用基础合约变量及覆盖变量。因此不要覆盖状态变量。(见[这里](https://swcregistry.io/docs/SWC-119))
41. **本地变量的声明前使用**。在声明之前使用一个变量（无论是后来声明的还是在另一个作用域中声明的）会在_solc < 0.5.0_中导致意外行为，但_solc >= 0.5.0_实现了C99风格的作用域规则，其中变量只能在声明之后使用，并且只能在相同或嵌套的作用域中使用。(参见[这里](https://github.com/crytic/slither/wiki/Detector-Documentation#pre-declaration-usage-of-local-variables))
42. **循环内的高成本操作**。循环内的状态变量更新(使用SSTOREs)等操作会耗费大量 Gas ，成本很高，并可能导致Out-Of-Gas错误。最好使用局部变量进行优化。(见[这里](https://github.com/crytic/slither/wiki/Detector-Documentation#costly-operations-inside-a-loop))
43. \*\*循环内的调用：\*\*循环内对外部合约的调用是危险的（特别是当循环索引可以由用户控制时），因为如果其中一个调用还原或执行耗尽 Gas ，可能导致DoS。避免在循环内调用，检查循环索引不能被用户控制或被约束。(参见[这里](https://swcregistry.io/docs/SWC-113))
44. **块 Gas Limit 的DoS**。当执行 Gas 成本超过块 Gas 限制时，例如在未知大小的数组上循环等编程模式可能导致DoS。(见[此处](https://swcregistry.io/docs/SWC-128))
45. **事件缺失**。应发出关键状态变化的事件(如所有者和其他关键参数)，以便在链外跟踪这一事件。(见[此处](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-events-access-control))
46. **未索引的事件参数**。某些事件的参数应被索引(如ERC20转移/批准事件)，以便将其纳入区块的bloom过滤器，以便更快地访问。如果不这样做，可能会混淆寻找此类索引事件的链外工具。(见[这里](https://github.com/crytic/slither/wiki/Detector-Documentation#unindexed-erc20-event-oarameters))
47. **库中事件签名不正确**。库中事件中使用的合约类型导致事件签名哈希值不正确。在哈希签名中没有使用 "address "类型，而是使用了实际的合约名称，导致日志中出现错误的哈希值。这是由于_v0.5.0_中引入的一个编译器错误，在_v0.5.8_中得到了修正（见[此处](https://docs.soliditylang.org/en/v0.8.1/bugs.html)）。
48. **危险的单元表达式**。诸如_x =+ 1_这样的单元表达式很可能是程序员真正想使用_x += 1_的错误表达。单元 _+运算符在solc v0.5.0_中已被废弃（参见[这里](https://swcregistry.io/docs/SWC-129)）。
49. **缺少零地址验证**。地址类型参数的设置者应包括零地址检查，否则合约函数可能无法访问或代币可能永远烧毁。(见[此处](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-zero-address-validation))
50. **关键地址变更**。更改合约中的关键地址应分两步进行，第一步交易（从旧地址/当前地址）登记新地址（即授予所有权），第二步交易（从新地址）用新地址取代旧地址（即要求所有权）。这样就有机会从第一步错误使用的错误地址中恢复过来。否则，合约函数可能会变得无法访问。(见[此处](https://github.com/OpenZeppelin/openzeppelin-contracts/issues/1488)和[此处](https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2369))
51. **assert()状态改变**。根据最佳做法，\*assert()_语句中的不变性检查不应修改状态。应使用_require()\*进行此类检查。(见[这里](https://swcregistry.io/docs/SWC-110))
52. **require() vs assert():** _require()应该用于检查输入和返回值的错误条件，而assert()应该用于不变性检查。在solc 0.4.10_和_0.8.0_之间，_require()使用REVERT_ (_0xfd_)操作码，在失败时退还剩余 Gas ，而\*assert()\*使用INVALID (_0xfe_)操作码，消耗了所有提供的 Gas 。(见[这里](https://docs.soliditylang.org/en/v0.8.1/control-structures.html#error-handling-assert-require-revert-and-exceptions))
53. **过时的关键字**。使用过时的函数/运算符，如_block.blockhash()为blockhash()_，msg.gas为_gasleft()，throw_为_revert()_，_sha3()为keccak256()_，_callcode()为delegatecall()，suicide()为selfdestruct()，constant为_view_或_var应为_准确的类型名_，应避免使用这些过时的函数/操作，以防止在新的编译器版本中出现意外错误。(见[这里](https://swcregistry.io/docs/SWC-111))
54. **函数默认可见性**: 在_solc < 0.5.0_中，没有指定可见性类型指定符时，则函数默认为_public_。这可能导致一个漏洞，恶意用户可能会进行未经授权的状态更改。_solc >= 0.5.0_ 需要显式函数可见性指定符。(参见[这里](https://swcregistry.io/docs/SWC-100))
55. **继承顺序不正确**。从具有相同函数的多个合约继承的合约应规定正确的继承顺序，即从一般到具体，以避免继承错误的函数实现。(见[此处](https://swcregistry.io/docs/SWC-125))
56. **继承缺失**。一个合约可能看起来（根据名称或实现的函数）继承自另一个接口或抽象合约，但实际上并没有这样做。（见[此处](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-inheritance)）
57. **Gas 不足**。交易中继者需要得到信任，才能为交易成功提供足够的 Gas 。(见[此处](https://swcregistry.io/docs/SWC-126))
58. **修改引用类型参数**。作为参数传递给函数的结构体/数组/映射可以是由数据位置指定的值类型（memory）或引用类型（storage）（在_solc 0.5.0_之前是可选的）。确保在函数参数中正确使用memory和storage，并显式表达所有数据位置。(参见[这里](https://github.com/crytic/slither/wiki/Detector-Documentation#modifying-storage-array-by-value))
59. \*\*用函数类型变量进行任意跳转：\*\*在汇编操作中应谨慎处理和避免函数类型变量，以防止跳转到任意代码位置。(见[这里](https://swcregistry.io/docs/SWC-127))
60. **有多个可变长度参数的散列碰撞**。在某些情况下，使用_abi.encodePacked()与多个可变长度参数一起使用可能会导致哈希碰撞。不要允许用户访问abi.encodePacked()中使用的参数。使用固定长度的数组或使用abi.encode()_。(见[这里](https://swcregistry.io/docs/SWC-133)和[这里](https://docs.soliditylang.org/en/v0.5.3/abi-spec.html#non-standard-packed-mode))
61. **脏的高阶位带来的可塑性风险**。没有占满32个字节的类型可能包含 "脏高阶位"，这不会影响对类型的操作，但对_msg.data_会产生不同的结果。(见[这里](https://docs.soliditylang.org/en/v0.8.1/security-considerations.html#minor-details))
62. **汇编中移位不正确**。Solidity汇编中的移位运算符(_shl(x, y)_, _shr(x, y)_, _sar(x, y)_)在_y_上应用_x_位的移位运算，而不是相反，这可能会引起混淆。检查移位操作中的值是否颠倒。(参见[这里](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-shift-in-assembly))
63. **汇编的使用**。使用EVM 汇编容易出错，应避免使用或仔细检查其正确性。(见[此处](https://github.com/crytic/slither/wiki/Detector-Documentation#assembly-usage))
64. **右向左覆盖控制字符（U+202E）**。恶意行为者可以使用 "右向左覆盖 "unicode字符来强制渲染RTL文本，并使用户混淆合约的真实意图。U+202E 字符不应该出现在智能合约的源代码中。(见[这里](https://swcregistry.io/docs/SWC-130))
65. **常量**。不变的状态变量应声明为常量，以节省 Gas 。(见[此处](https://github.com/crytic/slither/wiki/Detector-Documentation#state-variables-that-could-be-declared-constant))
66. **类似的变量名称**。名称相似的变量可能会相互混淆，因此应避免使用。（见[此处](https://github.com/crytic/slither/wiki/Detector-Documentation#variable-names-too-similar)）
67. **未初始化的状态/局部变量**。未初始化的状态/局部变量被编译器分配为零值，可能会造成意想不到的结果，例如将token转移到零地址。应明确初始化所有状态/局部变量。(参见 [这里](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-state-variables) 和 [这里](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-local-variables))
68. \*\*未初始化的存储指针：\*\*未初始化的本地存储变量可能指向合约中意想不到的存储位置，从而导致漏洞。_Solc 0.5.0_及以上版本不允许这种指针。(见[此处](https://swcregistry.io/docs/SWC-109))
69. \*\*在构造函数中调用未初始化的函数指针:\*\*由于编译器错误，在用_solc_版本_0.4.5-0.4.25_和_0.5.0-0.5.7_编译的合约的构造函数中调用未初始化的函数指针会导致意外行为。(见[这里](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-function-pointers-in-constructors))
70. **很长的数字常量**。应仔细检查有许多数字的数字常量，因为它们容易出错。(见[此处](https://github.com/crytic/slither/wiki/Detector-Documentation#too-many-digits))
71. **超出范围的枚举：** _Solc < 0.4.5_ 对超出范围的枚举产生了意外的行为\*.\* 检查枚举转换或使用更新的编译器。(参见[这里](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-enum-conversion))
72. **未调用的public函数**。从未在合约内调用的_public_函数应宣布为_external_，以节省gas。(见[此处](https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external))
73. **死代码/无法到达的代码**。死代码可能表明程序员出错、逻辑缺失或潜在的优化机会，需要标记出来予以删除或适当处理。(见[此处](https://en.wikipedia.org/wiki/Dead\_code))
74. **未使用的返回值**。函数调用中未使用的返回值表明程序员错误，可能会产生意外行为。(见[此处](https://github.com/crytic/slither/wiki/Detector-Documentation#unused-return))
75. **未使用的变量**。未使用的状态/局部变量可能表明程序员出错、逻辑缺失或潜在的优化机会，需要标记出来予以删除或适当处理。(见[此处](https://swcregistry.io/docs/SWC-131))
76. **多余的语句**。没有效果但不产生代码的语句可能表明程序员出错或逻辑缺失，需要标明删除或适当处理。(见[此处](https://swcregistry.io/docs/SWC-135))
77. **使用 ABIEncoderV2 带符号整数的存储数组**。将带符号整数数组分配给不同类型的存储数组可能导致数组中的数据损坏。这是由于_v0.4.7_中引入的一个编译器错误，并在_v0.5.10_中得到修复。(见[这里](https://docs.soliditylang.org/en/v0.8.1/bugs.html))
78. **动态构造函数参数被ABIEncoderV2**。当使用ABIEncoderV2时，包含动态大小数组的结构体或数组的合约构造函数会回退或解码为无效数据。这是由于在_v0.4.16_中引入的编译器错误，在_v0.5.9_中得到了修正。(参见[这里](https://docs.soliditylang.org/en/v0.8.1/bugs.html))
79. **带有ABIEncoderV2**的多槽元素的存储数组。当在外部函数调用中或在_abi.encode()中直接编码时，包含结构体或其他静态大小数组的存储数组无法正确读取。这是由于v0.4.16_中引入的一个编译器错误，并在_v0.5.10_中得到了修复。(参见[这里](https://docs.soliditylang.org/en/v0.8.1/bugs.html))
80. **使用ABIEncoderV2**读取含有静态大小和动态编码成员的Calldata结构。读取包含动态编码但静态大小的成员的Calldata结构可能会导致错误的值。这是由于_v0.5.6_中引入的一个编译器错误，并在_v0.5.11_中得到了修复。(参见[这里](https://docs.soliditylang.org/en/v0.8.1/bugs.html))
81. \*\*使用ABIEncoderV2的打包存储：\*\*如果使用ABIEncoderV2直接从存储中编码，类型短于32字节的存储结构体和数组可能导致数据损坏。这是由于_v0.5.0_中引入的一个编译器错误，并在_v0.5.7_中得到了修复。(见[这里](https://docs.soliditylang.org/en/v0.8.1/bugs.html))
82. **使用Yul优化器和ABIEncoderV2**的加载不正确。Yul优化器错误地将_MLOAD_和_SLOAD_调用替换为先前已写入加载位置的值。只有当ABIEncoderV2被激活，并且除了编译器设置中的常规优化器外，还手动激活了实验性的Yul优化器，才会发生这种情况。这是由于_v0.5.14_中引入的一个编译器错误，并在_v0.5.15_中进行了修复。(参见[这里](https://docs.soliditylang.org/en/v0.8.1/bugs.html))
83. **使用ABIEncoderV2动态编码基类型的数组切片**。访问基类型为动态编码的数组（如多维数组）的数组片断可能导致读取无效数据。这是由于_v0.6.0_中引入的编译器错误，在_v0.6.8_中进行了修正。(参见[这里](https://docs.soliditylang.org/en/v0.8.1/bugs.html))
84. \*\*在使用ABIEncoderV2时，格式化过程中缺少转义:\*\*当ABIEncoderV2被启用时，直接传递给外部或编码函数调用的包含双反斜杠字符的字符串常量会导致使用不同的字符串。这是由于在_v0.5.14_中引入的一个编译器错误，并在_v0.6.8_中进行了修复。(参见[这里](https://docs.soliditylang.org/en/v0.8.1/bugs.html))
85. **双移位溢出**。大常数的双位移位，其总和超过256位，会导致意外的数值。总移位大小为 2\*256 或更多的嵌套逻辑移位操作会被错误地优化。这只适用于由属于编译时常量表达式的位数进行的移位操作。这是由于_v0.5.5_中引入的编译器错误，并在_v0.5.6_中进行了修正。(参见[这里](https://docs.soliditylang.org/en/v0.8.1/bugs.html))
86. **不正确的字节指令优化**：优化器错误地处理了第二个参数为31的字节操作码或求值为31的常量表达式。这可能导致意外的值。当在_bytesNN_类型上执行编译时常量值（不是索引）为31的索引访问时，或在内联汇编中使用字节操作码时，会发生这种情况。这是由于_v0.5.5_中引入的编译器错误，并在_v0.5.7_中得到了修复。(参见[这里](https://docs.soliditylang.org/en/v0.8.1/bugs.html))
87. **用Yul优化器移除必要的赋值** 。当使用_for_循环、_continue_和_break_语句时，Yul优化器可以删除_for_循环内声明的变量的必要赋值。这是由于_v0.5.8_/_v0.6.0_中引入的一个编译器错误，并在_v0.5.16_/_v0.6.1_中得到了修复。(见[这里](https://docs.soliditylang.org/en/v0.8.1/bugs.html))
88. **私有方法被覆盖**。虽然基础合约的私有方法不可见，也不能直接从派生合约中调用，但仍然可以声明一个同名同类型的函数，从而改变基础合约函数的行为。这是由于_v0.3.0_中引入的一个编译器错误，并在_v0.5.17_中进行了修正。(见[此处](https://docs.soliditylang.org/en/v0.8.1/bugs.html))
89. **元组赋值多栈槽组件**。元组赋值的组件占用多个堆栈槽，例如嵌套的元组、外部函数指针或动态大小的calldata数组的引用，可能导致无效值。这是由于_v0.1.6_中引入的一个编译器错误，并在_v0.6.6_中得到了修正。(参见[这里](https://docs.soliditylang.org/en/v0.8.1/bugs.html))
90. **动态数组清理**。当分配一个动态大小的数组，其类型大小最多为16个字节，导致分配的数组收缩时，被删除的插槽的某些部分没有清零。这是编译器错误，在_v0.7.3_中修复。(见[这里](https://docs.soliditylang.org/en/v0.8.1/bugs.html))
91. **空字节数组复制**。将空字节数组(或字符串)从内存或Calldata复制到存储中，如果随后增加目标数组的长度而不存储新数据，可能导致数据损坏。这是一个编译器错误，在_v0.7.4_中修复。(见[这里](https://docs.soliditylang.org/en/v0.8.1/bugs.html))
92. **内存数组创建溢出**。创建非常大的内存数组可能导致内存区域重叠，从而导致内存损坏。这是由于_v0.2.0_中引入的一个编译器错误，在_v0.6.5_中得到了修复。(参见[这里](https://solidity.ethereum.org/2020/04/06/memory-creation-overflow-bug/))
93. **Calldata using for**。调用带有calldata参数的内部库函数，如果通过 "_using for "调用，可能导致读取无效数据。这是由于v0.6.9_中引入的一个编译器错误，在_v0.6.10_中得到了修复。(参见[这里](https://docs.soliditylang.org/en/v0.8.1/bugs.html))
94. **自由函数的重新定义**。当在一个源代码单元中定义了两个或更多具有相同名称和参数类型的自由函数(合约之外的函数)时，或当一个导入的自由函数别名覆盖了另一个名称不同但参数类型相同的自由函数时，编译器没有标记错误。这是由于_v0.7.1_中引入的一个编译器错误，并在_v0.7.2_中进行了修正。(参见[这里](https://docs.soliditylang.org/en/v0.8.1/bugs.html))
95. **基于代理的可升级合约中未加保护的初始化器**。基于代理的可升级合约需要使用_public_初始化函数，而不是用明确调用一次的构造函数。防止多次调用这种初始化函数（例如通过OpenZeppelin的_Initializable_库中的_initializer_修改器）是必须的。(参见[这里](https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers)和[这里](https://github.com/crytic/slither/wiki/Upgradeability-Checks#initializer-is-not-called))
96. **初始化基于代理的可升级合约中的状态变量**。这应该在初始化函数中进行，而不是作为状态变量声明的一部分，在这种情况下，状态变量不会被设置。(见[此处](https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#avoid-initial-values-in-field-declarations))
97. **导入基于代理的可升级合约**。从基于代理的可升级合约中导入的合约也应是可升级的，因为这些合约已被修改为使用初始化器而不是构造器。(见[此处](https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#use-upgradeable-libraries))
98. **避免在基于代理的可升级合约中使用selfdestruct或delegatecall**。这将导致逻辑合约被销毁，所有的合约实例最终将委托调用一个地址，而不需要任何代码。(见[这里](https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#potentially-unsafe-operations))
99. **基于代理的可升级合约中的状态变量**。这种合约中状态变量的声明顺序/布局和类型/可变性应在升级时准确地保留，以防止关键的存储布局不匹配错误。（见\[此处]（[https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#modifying-your-contracts））](https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#modifying-your-contracts%EF%BC%89%EF%BC%89)
100. **基于代理的可升级合约中代理/合约之间的函数ID碰撞**。恶意代理合约可能会利用函数ID碰撞来调用非预期的代理函数而不是合约函数。检查函数ID碰撞。(见[这里](https://github.com/crytic/slither/wiki/Upgradeability-Checks#functions-ids-collisions)和[这里](https://forum.openzeppelin.com/t/beware-of-the-proxy-learn-how-to-exploit-function-clashing/1070))
101. **基于代理的可升级合约中代理/合约函数之间的覆盖**。代理合约中的覆盖函数防止逻辑合约中的函数被调用。(见[此处](https://github.com/crytic/slither/wiki/Upgradeability-Checks#functions-shadowing))
